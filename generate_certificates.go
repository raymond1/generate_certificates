package main

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"strings"
)

var rootAuthorityPrivateKeyFilename = "root.pem"
var intermediateAuthorityPrivateKeyFilename = "intermediate.pem"
var serverPrivateKeyFilename = "server.pem"

//Takes in a string and runs the command in a shell
func runCommand(command string) error {
	executableCommand := convertStringIntoExecCommand(command)
	return executableCommand.Run()
}

//Takes in a string and produces Cmd object that can be run
func convertStringIntoExecCommand(command string) *exec.Cmd {
	arguments := strings.Split(command, " ")
	return exec.Command(arguments[0], arguments[1:]...)
}

//Incorrect
func signCertificate(signerPrivateKey string, certificateSigningRequest string, outputCertificate string) {
	//openssl ca -selfsign -keyfile root.pem -config root_ca.conf -out root.crt -in root.csr -outdir root_certificates -verbose -batch
	command := ""
	executableCommand := convertStringIntoExecCommand(command)
	executableCommand.Run()
}

//Overview: Takes in the root private key along with some other required information and generates a certificate for it.
//
//The specific parameters required are:
//rootPrivateKey: a string to the file containing the root private key
//certificateSigningRequest: a string path to the certificate signing request file. (The certificate signing request contains the information that will be signed into the certificate.)
//outputCertificate: a string path specifying the output file storing the generated certificate
//domainName: For this program, the domain name is used as the folder name where output files are stored.
func generateSelfSignedCertificate(rootPrivateKey string, certificateSigningRequest string, outputCertificate string, domainName string, outputDirectory string) {
	rootAuthorityConfigurationFile := "config/root_ca.conf"
	command := fmt.Sprintf("openssl ca -selfsign -keyfile %s -config %s -out %s -in root.csr -outdir %s -verbose -batch",
		rootPrivateKey, rootAuthorityConfigurationFile, outputCertificate, outputDirectory)
	runCommand(command)
}

//Generates a certificate signing request
func generateCertificateSigningRequest(privateKey string, configuration string, outputCertificate string) {
	//openssl req -key root.pem -out root.csr -days 398 -new -config root_csr.conf
	arguments := []string{"req", "-key", privateKey, "-out", outputCertificate, "-days", "398", "-new", "-config", configuration}
	cmd := exec.Command("openssl", arguments...)

	if err := cmd.Run(); err != nil {
		fmt.Println("An error occurred when trying to generate the certificate signing request for key " + privateKey + " using the configuration " + configuration)
		fmt.Println(err)
	}

	fmt.Println(arguments)
}

//Uses OpenSSL to generate a private key
func generatePrivateKey(filename string) {
	command := fmt.Sprintf("openssl genpkey -outform pem -out %s -algorithm rsa", filename)
	err := runCommand(command)

	if err != nil {
		fmt.Println("An error occurred when trying to generate private key " + filename + " using OpenSSL.")
		fmt.Println(err)
	}
}

//Returns true if file or directory passed in exists
func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	if errors.Is(err, os.ErrNotExist) {
		return false
	}
	return true
}

//Takes in an output directory and generates 3 private keys, one for the root authority, one for the intermediate authority, and one for the server hosting the domain name.
func makePrivateKeys(outputDirectory string) {
	//1)Ensure a directory named after the domain name passed in always exists
	if !fileExists(outputDirectory) {
		fmt.Println("Generating directory: " + outputDirectory)
		os.Mkdir(outputDirectory, 0700)
	}

	//2)Create a root authority private key if it doesn't already exist. Do not replace an existing one
	//openssl genpkey -outform pem -out root.pem -algorithm rsa
	rootAuthorityPrivateKey := fmt.Sprintf("%s/%s", outputDirectory, rootAuthorityPrivateKeyFilename)
	if !fileExists(rootAuthorityPrivateKey) {
		fmt.Println("Generating root private key: " + rootAuthorityPrivateKey)
		generatePrivateKey(rootAuthorityPrivateKey)
	}

	//3)Create an intermediate authority private key
	intermediateAuthorityPrivateKey := fmt.Sprintf("%s/%s", outputDirectory, intermediateAuthorityPrivateKeyFilename)
	if !fileExists(intermediateAuthorityPrivateKey) {
		fmt.Println("Generating intermediate private key: " + rootAuthorityPrivateKey)
		generatePrivateKey(intermediateAuthorityPrivateKey)
	}

	//4)Generate a server private key
	serverPrivateKey := fmt.Sprintf("%s/%s", outputDirectory, serverPrivateKeyFilename)
	if !fileExists(serverPrivateKey) {
		fmt.Println("Generating server private key: " + serverPrivateKey)
		generatePrivateKey(serverPrivateKey)
	}
}

//Usage: go run generate_certificates.go <domain.name>
//domain.name will be created as a directory and files generated by generate_certificates.go will go into the directory with name "domain.name".

//In the code, the term "server" refers to the computer hosting the name domain.name
func main() {
	//Force there to be exactly two arguments, the name of the file and the domain name
	if len(os.Args) != 2 {
		fmt.Println("Error: no domain name specified.")
		fmt.Println("usage: go run generate_certificates.go <domain.name>")
		os.Exit(0)
	}

	domainName := os.Args[1]
	outputDirectory := "output/" + domainName

	//Stage 1
	makePrivateKeys(outputDirectory)

	//Stage 2
	//1)Generate root certificate
	//2)Generate intermediate certificate
	//3)Generate server certificate
	// rootCertificate := fmt.Sprintf("")
	// if !fileExists(rootCertificate) {
	// 	fmt.Println("Generating root certificate from root private key.")
	// 	//generateCertificate()
	// 	// + rootAuthorityPrivateKey + " using configuration options from " +)
	// 	// openssl ca -selfsign -keyfile root.pem -config root_ca.conf -out root.crt -in root.csr -outdir root_certificates -verbose -batch
	// }
	// //root_csr.conf

	rootCSR := fmt.Sprintf("%s/root.csr", outputDirectory)
	if !fileExists(rootCSR) {
		fmt.Println("Generating root CSR.")
		generateCertificateSigningRequest(outputDirectory+"/"+rootAuthorityPrivateKeyFilename, "config/root_csr.conf", rootCSR)
	}

	rootCertificate := fmt.Sprintf("%s/root.crt", outputDirectory)
	if !fileExists(rootCertificate) {
		fmt.Println("Generating root certificate")
		generateSelfSignedCertificate(outputDirectory+"/"+rootAuthorityPrivateKeyFilename, rootCSR, rootCertificate, domainName, outputDirectory)
	}
}
